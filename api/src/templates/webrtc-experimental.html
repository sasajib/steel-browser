<!doctype html>
<html>
  <head>
    <title>Video Canvas</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: black;
        height: 100%;
        overflow: hidden;
      }
      #videoCanvas {
        display: block;
        cursor: none;
        width: 100vw;
        height: 100vh;
      }
      #hiddenVideo {
        display: none;
      }
    </style>
  </head>
  <body>
    <video id="hiddenVideo" autoplay playsinline muted></video>
    <canvas id="videoCanvas" tabindex="0"></canvas>

    <script>
      const ws = new WebSocket("ws://172.56.253.95:8080/signal");

      const pc = new RTCPeerConnection({
        iceServers: [
          {
            urls: "stun:stun.relay.metered.ca:80",
          },
          {
            urls: "turn:global.relay.metered.ca:80",
            username: "f5a4e67eeccfa1291bfd824c",
            credential: "HJ+o8FRYh6/9xJKI",
          },
          {
            urls: "turn:global.relay.metered.ca:80?transport=tcp",
            username: "f5a4e67eeccfa1291bfd824c",
            credential: "HJ+o8FRYh6/9xJKI",
          },
          {
            urls: "turn:global.relay.metered.ca:443",
            username: "f5a4e67eeccfa1291bfd824c",
            credential: "HJ+o8FRYh6/9xJKI",
          },
          {
            urls: "turns:global.relay.metered.ca:443?transport=tcp",
            username: "f5a4e67eeccfa1291bfd824c",
            credential: "HJ+o8FRYh6/9xJKI",
          },
        ],
      });

      const hiddenVideo = document.getElementById("hiddenVideo");
      const canvas = document.getElementById("videoCanvas");
      const ctx = canvas.getContext("2d");
      let animationFrame;
      let videoWidth = 0,
        videoHeight = 0;

      // Ask for high-res stream if supported
      pc.addTransceiver("video", {
        direction: "recvonly",
        sendEncodings: [{ maxBitrate: 5000000 }], // 5 Mbps request
      });

      // Resize canvas to fill window
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Handle incoming video
      pc.ontrack = (event) => {
        hiddenVideo.srcObject = event.streams[0];
        hiddenVideo.addEventListener("loadedmetadata", () => {
          videoWidth = hiddenVideo.videoWidth;
          videoHeight = hiddenVideo.videoHeight;
          renderVideoToCanvas();
        });
      };

      function renderVideoToCanvas() {
        // Draw video scaled to canvas size
        ctx.drawImage(hiddenVideo, 0, 0, canvas.width, canvas.height);
        animationFrame = requestAnimationFrame(renderVideoToCanvas);
      }

      // ICE candidate sending
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          ws.send(
            JSON.stringify({
              type: "ice-candidate",
              data: {
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex,
              },
            }),
          );
        }
      };

      // Scale mouse coords to video resolution
      function getScaledCoords(e) {
        const scaleX = videoWidth / canvas.width;
        const scaleY = videoHeight / canvas.height;
        return {
          x: Math.floor(e.offsetX * scaleX),
          y: Math.floor(e.offsetY * scaleY),
        };
      }

      // Mouse events
      canvas.addEventListener("mousemove", (e) => {
        const { x, y } = getScaledCoords(e);
        ws.send(JSON.stringify({ type: "mouse", data: { x, y, action: "move" } }));
      });

      canvas.addEventListener("mousedown", (e) => {
        e.preventDefault();
        const { x, y } = getScaledCoords(e);
        let button = e.button === 1 ? "middle" : e.button === 2 ? "right" : "left";
        ws.send(JSON.stringify({ type: "mouse", data: { x, y, button, action: "down" } }));
      });

      canvas.addEventListener("mouseup", (e) => {
        e.preventDefault();
        const { x, y } = getScaledCoords(e);
        let button = e.button === 1 ? "middle" : e.button === 2 ? "right" : "left";
        ws.send(JSON.stringify({ type: "mouse", data: { x, y, button, action: "up" } }));
      });

      canvas.addEventListener("click", (e) => {
        e.preventDefault();
        const { x, y } = getScaledCoords(e);
        ws.send(JSON.stringify({ type: "mouse", data: { x, y, button: "left", action: "click" } }));
      });

      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const { x, y } = getScaledCoords(e);
        ws.send(
          JSON.stringify({ type: "mouse", data: { x, y, button: "right", action: "click" } }),
        );
      });

      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const { x, y } = getScaledCoords(e);
        const button = e.deltaY < 0 ? "4" : "5";
        ws.send(JSON.stringify({ type: "mouse", data: { x, y, button, action: "click" } }));
      });

      // Keyboard: typing + special keys
      canvas.addEventListener("keydown", (e) => {
        e.preventDefault();
        let key = e.key;

        // Handle printable characters
        if (e.key.length === 1 && !e.ctrlKey && !e.altKey) {
          ws.send(JSON.stringify({ type: "keyboard", data: { key, action: "type" } }));
          return;
        }

        // Handle special named keys
        if (e.key === "Enter") key = "enter";
        else if (e.key === "Backspace") key = "backspace";
        else if (e.key === "Tab") key = "tab";
        else if (e.ctrlKey && e.key !== "Control") key = "ctrl+" + e.key.toLowerCase();
        else if (e.altKey && e.key !== "Alt") key = "alt+" + e.key.toLowerCase();
        else if (e.shiftKey && e.key !== "Shift" && e.key.length > 1)
          key = "shift+" + e.key.toLowerCase();

        ws.send(JSON.stringify({ type: "keyboard", data: { key, action: "down" } }));
      });

      canvas.addEventListener("keyup", (e) => {
        e.preventDefault();
        let key = e.key;
        if (e.ctrlKey && e.key !== "Control") key = "ctrl+" + e.key.toLowerCase();
        else if (e.altKey && e.key !== "Alt") key = "alt+" + e.key.toLowerCase();
        else if (e.shiftKey && e.key !== "Shift" && e.key.length > 1)
          key = "shift+" + e.key.toLowerCase();

        ws.send(JSON.stringify({ type: "keyboard", data: { key, action: "up" } }));
      });

      // Clipboard support
      window.addEventListener("paste", (e) => {
        const text = e.clipboardData.getData("text");
        if (text) ws.send(JSON.stringify({ type: "clipboard", data: { text, action: "paste" } }));
      });
      window.addEventListener("copy", () => {
        ws.send(JSON.stringify({ type: "clipboard", data: { action: "copy" } }));
      });

      // WebSocket signalling
      ws.onopen = async () => {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({ type: "offer", data: { type: offer.type, sdp: offer.sdp } }));
      };

      ws.onmessage = async (event) => {
        const msg = JSON.parse(event.data);
        if (msg.type === "answer") await pc.setRemoteDescription(msg.data);
        else if (msg.type === "ice-candidate") await pc.addIceCandidate(msg.data);
      };

      ws.onclose = () => {
        if (animationFrame) cancelAnimationFrame(animationFrame);
      };
    </script>
  </body>
</html>
