<!doctype html>
<html>
  <head>
    <title>Interactive WebRTC Stream</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background: #f0f0f0;
      }
      .container {
        max-width: 1800px;
        margin: 0 auto;
      }
      #videoCanvas {
        width: 100%;
        /*max-width: 800px;*/
        border: 2px solid #333;
        cursor: none;
        display: block;
        margin: 0 auto 20px auto;
        background: #000;
      }
      #videoCanvas:focus {
        outline: 2px solid #007bff;
        outline-offset: 2px;
      }
      #hiddenVideo {
        display: none;
      }
      .controls {
        text-align: center;
        margin: 20px 0;
      }
      .control-group {
        margin: 10px;
        display: inline-block;
      }
      input,
      textarea,
      button {
        padding: 8px;
        margin: 5px;
        font-size: 14px;
      }
      #clipboardText {
        width: 300px;
        height: 60px;
      }
      .status {
        text-align: center;
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
      }
      .status.connected {
        background: #d4edda;
        color: #155724;
      }
      .status.disconnected {
        background: #f8d7da;
        color: #721c24;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- <h1>Interactive WebRTC Stream</h1> -->
      <div id="status" class="status disconnected">Disconnected</div>
      <video id="hiddenVideo" autoplay playsinline muted></video>
      <canvas id="videoCanvas"></canvas>
      <!-- <div class="controls">
        <div class="control-group">
          <h3>Clipboard</h3>
          <textarea id="clipboardText" placeholder="Text to paste..."></textarea
          ><br />
          <button onclick="pasteText()">Paste to Stream</button>
          <button onclick="copyFromStream()">Copy from Stream</button>
        </div>

        <div class="control-group">
          <h3>Keyboard</h3>
          <input
            type="text"
            id="keyInput"
            placeholder="Type here to send keys..."
            style="width: 200px"
          />
          <button onclick="sendSpecialKey('ctrl+c')">Ctrl+C</button>
          <button onclick="sendSpecialKey('ctrl+v')">Ctrl+V</button>
          <button onclick="sendSpecialKey('ctrl+a')">Ctrl+A</button>
        </div>
      </div> -->
    </div>

    <script>
      // const ws = new WebSocket({{.WS_URL}});
      const ws = new WebSocket("ws://localhost:3001/v1/sessions/webrtc");
      const pc = new RTCPeerConnection({
        // iceServers: {{.ICE_SERVERS}}
        iceServers: [
          {
            urls: "stun:stun.relay.metered.ca:80",
          },
          {
            urls: "turn:global.relay.metered.ca:80",
            username: "0ee5e77192b5e67f471b8bc9",
            credential: "6K8IOBskAee2gm7i",
          },
          {
            urls: "turn:global.relay.metered.ca:80?transport=tcp",
            username: "0ee5e77192b5e67f471b8bc9",
            credential: "6K8IOBskAee2gm7i",
          },
          {
            urls: "turn:global.relay.metered.ca:443",
            username: "0ee5e77192b5e67f471b8bc9",
            credential: "6K8IOBskAee2gm7i",
          },
          {
            urls: "turns:global.relay.metered.ca:443?transport=tcp",
            username: "0ee5e77192b5e67f471b8bc9",
            credential: "6K8IOBskAee2gm7i",
          },
        ],
      });

      const hiddenVideo = document.getElementById("hiddenVideo");
      const canvas = document.getElementById("videoCanvas");
      const ctx = canvas.getContext("2d");
      const status = document.getElementById("status");
      let animationFrame;

      // Add transceiver to receive video
      pc.addTransceiver("video", { direction: "recvonly" });

      pc.ontrack = (event) => {
        console.log("Received track:", event.track);
        hiddenVideo.srcObject = event.streams[0];

        hiddenVideo.addEventListener("loadedmetadata", () => {
          // Set canvas size to match video
          canvas.width = hiddenVideo.videoWidth;
          canvas.height = hiddenVideo.videoHeight;

          // Start rendering video to canvas
          renderVideoToCanvas();
        });
      };

      function renderVideoToCanvas() {
        if (hiddenVideo.videoWidth > 0 && hiddenVideo.videoHeight > 0) {
          ctx.drawImage(hiddenVideo, 0, 0, canvas.width, canvas.height);
        }
        animationFrame = requestAnimationFrame(renderVideoToCanvas);
      }

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          ws.send(
            JSON.stringify({
              type: "ice-candidate",
              data: {
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex,
              },
            }),
          );
        }
      };

      pc.oniceconnectionstatechange = () => {
        console.log("ICE connection state:", pc.iceConnectionState);
        updateStatus(pc.iceConnectionState);
      };

      function updateStatus(state) {
        if (state === "connected" || state === "completed") {
          status.textContent = "Connected";
          status.className = "status connected";
        } else {
          status.textContent = "Disconnected (" + state + ")";
          status.className = "status disconnected";
        }
      }

      // Mouse event handling on canvas
      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = Math.floor((e.clientX - rect.left) * scaleX);
        const y = Math.floor((e.clientY - rect.top) * scaleY);

        ws.send(
          JSON.stringify({
            type: "mouse",
            data: { x, y, action: "move" },
          }),
        );
      });

      canvas.addEventListener("click", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = Math.floor((e.clientX - rect.left) * scaleX);
        const y = Math.floor((e.clientY - rect.top) * scaleY);

        ws.send(
          JSON.stringify({
            type: "mouse",
            data: { x, y, button: "left", action: "click" },
          }),
        );
      });

      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = Math.floor((e.clientX - rect.left) * scaleX);
        const y = Math.floor((e.clientY - rect.top) * scaleY);

        ws.send(
          JSON.stringify({
            type: "mouse",
            data: { x, y, button: "right", action: "click" },
          }),
        );
      });

      // Mouse down/up for drag operations
      canvas.addEventListener("mousedown", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = Math.floor((e.clientX - rect.left) * scaleX);
        const y = Math.floor((e.clientY - rect.top) * scaleY);

        let button = "left";
        if (e.button === 1) button = "middle";
        if (e.button === 2) button = "right";

        ws.send(
          JSON.stringify({
            type: "mouse",
            data: { x, y, button, action: "down" },
          }),
        );
      });

      canvas.addEventListener("mouseup", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = Math.floor((e.clientX - rect.left) * scaleX);
        const y = Math.floor((e.clientY - rect.top) * scaleY);

        let button = "left";
        if (e.button === 1) button = "middle";
        if (e.button === 2) button = "right";

        ws.send(
          JSON.stringify({
            type: "mouse",
            data: { x, y, button, action: "up" },
          }),
        );
      });

      // Scroll wheel support
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = Math.floor((e.clientX - rect.left) * scaleX);
        const y = Math.floor((e.clientY - rect.top) * scaleY);

        // Send scroll as mouse button 4 (scroll up) or 5 (scroll down)
        const button = e.deltaY < 0 ? "4" : "5";
        ws.send(
          JSON.stringify({
            type: "mouse",
            data: { x, y, button, action: "click" },
          }),
        );
      });

      // Make canvas focusable for keyboard events
      canvas.setAttribute("tabindex", "0");
      canvas.addEventListener("focus", () => {
        console.log("Canvas focused - keyboard input enabled");
      });

      canvas.addEventListener("keydown", (e) => {
        e.preventDefault();

        let key = e.key;
        // Handle special key combinations
        if (e.ctrlKey && e.key !== "Control") {
          key = "ctrl+" + e.key.toLowerCase();
        } else if (e.altKey && e.key !== "Alt") {
          key = "alt+" + e.key.toLowerCase();
        } else if (e.shiftKey && e.key !== "Shift") {
          // For printable characters, shift is handled naturally
          // For special keys, we might want to handle them
          if (e.key.length > 1) {
            key = "shift+" + e.key.toLowerCase();
          }
        }

        ws.send(
          JSON.stringify({
            type: "keyboard",
            data: { key: key, action: "down" },
          }),
        );
      });

      canvas.addEventListener("keyup", (e) => {
        e.preventDefault();

        let key = e.key;
        if (e.ctrlKey && e.key !== "Control") {
          key = "ctrl+" + e.key.toLowerCase();
        } else if (e.altKey && e.key !== "Alt") {
          key = "alt+" + e.key.toLowerCase();
        } else if (e.shiftKey && e.key !== "Shift") {
          if (e.key.length > 1) {
            key = "shift+" + e.key.toLowerCase();
          }
        }

        ws.send(
          JSON.stringify({
            type: "keyboard",
            data: { key: key, action: "up" },
          }),
        );
      });

      // Keyboard event handling
      document.getElementById("keyInput").addEventListener("input", (e) => {
        const text = e.target.value;
        if (text) {
          ws.send(
            JSON.stringify({
              type: "keyboard",
              data: { key: text, action: "type" },
            }),
          );
          e.target.value = ""; // Clear input
        }
      });

      // Global keyboard capture when video is focused
      canvas.addEventListener("keydown", (e) => {
        e.preventDefault();
        ws.send(
          JSON.stringify({
            type: "keyboard",
            data: { key: e.key, action: "down" },
          }),
        );
      });

      // Clipboard functions
      function pasteText() {
        const text = document.getElementById("clipboardText").value;
        if (text) {
          ws.send(
            JSON.stringify({
              type: "clipboard",
              data: { text: text, action: "paste" },
            }),
          );
        }
      }

      function copyFromStream() {
        ws.send(
          JSON.stringify({
            type: "clipboard",
            data: { action: "copy" },
          }),
        );
      }

      function sendSpecialKey(key) {
        ws.send(
          JSON.stringify({
            type: "keyboard",
            data: { key: key, action: "down" },
          }),
        );
      }

      // WebSocket handling
      ws.onopen = async () => {
        console.log("WebSocket connected");
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(
          JSON.stringify({
            type: "offer",
            data: {
              type: offer.type,
              sdp: offer.sdp,
            },
          }),
        );
      };

      ws.onmessage = async (event) => {
        const msg = JSON.parse(event.data);

        if (msg.type === "answer") {
          await pc.setRemoteDescription(msg.data);
        } else if (msg.type === "ice-candidate") {
          await pc.addIceCandidate(msg.data);
        }
      };

      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
      };

      ws.onclose = () => {
        console.log("WebSocket closed");
        updateStatus("disconnected");
        // Stop animation frame when connection closes
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
        }
      };
    </script>
  </body>
</html>
